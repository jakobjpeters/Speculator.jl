var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"SpeculationBenchmark\nspeculate_repl\nspeculate","category":"page"},{"location":"references/#Speculator.SpeculationBenchmark","page":"References","title":"Speculator.SpeculationBenchmark","text":"SpeculationBenchmark <: Any\nSpeculationBenchmark(predicate = Returns(true), value;\n    limit::Integer = 1, trials::Integer = 8\n)\n\nBenchmark the compilation time in the workload generated by speculate(predicate, value; samples, limit).\n\nThis runs a compilation workload for each of the trials. Each trial occurs in a new process so that compiled methods are not cached across trials. The trials run the workload with dry = true to compile methods in Speculator.jl, then dry = false to measure the runtime within Speculator.jl and calls to precompile, and finally dry = false to measure the runtime within Speculator.jl. The result of a trial, an estimate of the runtime of calls to precompile in the workload, is the difference between the second and third runs.\n\nSee also speculate_repl and speculate.\n\ntip: Tip\nInitializing a temporary project and running precompilation workloads may take a substantial amount of time to complete. It is recommended to select an appropriate workload using speculate(; dry = true, verbosity = debug | review) before creating a benchmark.\n\nInterface\n\nThis type implements the iteration interface and part of the indexing interface.\n\neltype(::Type{<:SpeculationBenchmark})\nfirstindex(::SpeculationBenchmark)\ngetindex(::SpeculationBenchmark, ::Integer)\niterate(::SpeculationBenchmark, ::Integer)\niterate(::SpeculationBenchmark)\nlastindex(::SpeculationBenchmark)\nlength(::SpeculationBenchmark)\nshow(::IO, ::MIME\"text/plain\", ::SpeculationBenchmark)\n\n\n\n\n\n","category":"type"},{"location":"references/#Speculator.speculate_repl","page":"References","title":"Speculator.speculate_repl","text":"speculate_repl(predicate = Returns{Bool}(true);\n    install::Bool = true, background::Bool = true,\nparameters...)\n\nInstall a hook that calls speculate(predicate, value; background, parameters...) on each input value in the REPL.\n\nSubsequent calls to this function may be used to replace the hook. The hook may be removed using speculate_repl(; install = false). This function has no effect in non-interactive sessions.\n\nSee also SpeculationBenchmark and speculate.\n\ntip: Tip\nUse this in a startup.jl file to reduce latency in the REPL.\n\njulia> speculate_repl(; limit = 2, verbosity = debug)\n[ Info: The REPL will call `speculate` with each input\n\njulia> f() = nothing;\n[ Info: Compiled `Main.Example.f()`\n\njulia> g(::Union{String, Symbol}) = nothing;\n[ Info: Compiled `Main.Example.g(::String)`\n[ Info: Compiled `Main.Example.g(::Symbol)`\n\njulia> speculate_repl(; install = false)\n[ Info: The REPL will not call `speculate` with each input\n\n\n\n\n\n","category":"function"},{"location":"references/#Speculator.speculate","page":"References","title":"Speculator.speculate","text":"speculate(predicate, value; parameters)\nspeculate(value; parameters...)\n\nGenerate a compilation a workload.\n\nSee also SpeculationBenchmark and speculate.\n\ntip: Tip\nUse this in a package to reduce latency for its users.\n\nnote: Note\nThis function only runs when called during precompilation or an interactive session, or when writing precompilation directives to a file.\n\nParameters\n\npredicate = Returns(true):   This must have the signature predicate(::Module, ::Symbol)::Bool,   and is checked for each name given by names(::Module; all = true).   Returning true specifies to search getproperty(::Module, ::Symbol),   whereas returning false specifies to ignore the value.   The default predicate Returns{Bool}(true) will search every possible method,   up to its generic limit, whereas the predicate Returns(false) will   only search for methods of values passed directly to speculate.   This new value can also be accessed in the same manner within the predicate.   Some useful predicates include Base.isexported, Base.ispublic,   checking properties of the value itself, and a combination thereof.\nvalue:   When given a Module, speculate will recursively search its   contents using names(::Module; all = true).   For each other value, each of their generic methods   are searched for corresponding compilable signatures.\n\nKeyword parameters\n\nbackground::Bool = false:   Specifies whether to precompile on a thread in the :default pool.   The number of available threads can be determined using Threads.nthreads(:default).   In an interactive session with debug in the verbosity,   a call to sleep(0.01) is used to keep the REPL prompt active.\ndry::Bool = false:   Specifies whether to run precompile on generated method signatures.   This is useful for testing workloads with verbosity = debug.   Methods that are known to be specialized are skipped.   Note that dry must be false to save the workload to a file with the path parameter.\nlimit::Integer = 1:   Specifies the maximum number of compilable methods that are generated from a generic method.   Values less than 1 will throw an error.   Otherwise, method signatures will be generated from the Cartesian product each parameter type.   Concrete types and abstract types marked with @nospecialize are used directly.   Otherwise, compilable types are obtained from the subtypes of DataType and Union.   This prevents spending too much time precompiling a single generic method.\npath::String = \"\":   Writes each successful precompilation directive to a file   if the path is not empty and it is not a dry run.   Note that these directives may require loading additional modules to run.\nverbosity::Verbosity = warn:   Specifies what logging statements to show.   If this function is used as a precompilation workload,   this should be set to silent or warn.   See also Verbosity.\n\nExamples\n\njulia> module Showcase\n           export g, h\n\n           f() = nothing\n           g(::Int) = nothing\n           h(::Union{String, Symbol}) = nothing\n       end;\n\njulia> speculate(Showcase; verbosity = debug)\n[ Info: Compiled `Main.Showcase.g(::Int)`\n[ Info: Compiled `Main.Showcase.f()`\n\njulia> speculate(Base.isexported, Showcase; verbosity = debug)\n[ Info: Skipped `Main.Showcase.g(::Int)`\n\njulia> speculate(Showcase.h; limit = 2, verbosity = debug)\n[ Info: Compiled `Main.Showcase.h(::String)`\n[ Info: Compiled `Main.Showcase.h(::Symbol)`\n\n\n\n\n\n","category":"function"},{"location":"references/#Verbosity","page":"References","title":"Verbosity","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Verbosity\ndebug\nreview\nsilent\nwarn","category":"page"},{"location":"references/#Speculator.Verbosity","page":"References","title":"Speculator.Verbosity","text":"Verbosity\n\nA flag that determine what logging statements are shown during speculate.\n\nThe component flags are silent, debug, review, and warn.\n\nInterface\n\n|(::Verbosity, ::Verbosity)\nCombine the verbosities such that each satisfies issubset with the returned verbosity.\nissubset(::Verbosity, ::Verbosity)\nCheck whether each flag of the first verbosity is a component of the second verbosity.\nshow(::IO, ::Verbosity)\n\nExamples\n\njulia> silent\nsilent::Verbosity\n\njulia> debug | review\n(debug | review)::Verbosity\n\njulia> debug ⊆ debug | review\ntrue\n\njulia> debug ⊆ warn\nfalse\n\n\n\n\n\n","category":"type"},{"location":"references/#Speculator.debug","page":"References","title":"Speculator.debug","text":"debug::Verbosity\n\nA flag of Verbosity which specifies that speculate will show each successful call to precompile.\n\nExamples\n\njulia> debug\ndebug::Verbosity\n\n\n\n\n\n","category":"constant"},{"location":"references/#Speculator.review","page":"References","title":"Speculator.review","text":"review::Verbosity\n\nA flag of Verbosity which specifies that speculate will show the total number of values that have been speculated.\n\nExamples\n\njulia> debug\ndebug::Verbosity\n\n\n\n\n\n","category":"constant"},{"location":"references/#Speculator.silent","page":"References","title":"Speculator.silent","text":"silent::Verbosity\n\nA flag of Verbosity which specifies that speculate will not show any logging statements.\n\nExamples\n\njulia> silent\nsilent::Verbosity\n\n\n\n\n\n","category":"constant"},{"location":"references/#Speculator.warn","page":"References","title":"Speculator.warn","text":"warn::Verbosity\n\nA flag of Verbosity which specifies that speculate will show warnings for failed calls to precompile.\n\nExamples\n\njulia> warn\nwarn::Verbosity\n\n\n\n\n\n","category":"constant"},{"location":"#Speculator.jl","page":"Speculator.jl","title":"Speculator.jl","text":"","category":"section"},{"location":"#Introduction","page":"Speculator.jl","title":"Introduction","text":"","category":"section"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"Speculator.jl is a tool to reduce latency by automatically generating and running compilation workloads.","category":"page"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"Code needs to be compiled, either upon the installation of a package or as needed during runtime. In the former case, this can be used in a package as a supplement or alternative to PrecompileTools.jl. In the latter case, it can be used in a startup.jl file or interactively in the REPL.","category":"page"},{"location":"#Usage","page":"Speculator.jl","title":"Usage","text":"","category":"section"},{"location":"#Installation","page":"Speculator.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"julia> using Pkg: add\n\njulia> add(; url = \"https://github.com/jakobjpeters/Speculator.jl\")\n\njulia> using Speculator","category":"page"},{"location":"#Showcase","page":"Speculator.jl","title":"Showcase","text":"","category":"section"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"julia> module Showcase\n           export g, h\n\n           f() = nothing\n           g(::Int) = nothing\n           h(::Union{String, Symbol}) = nothing\n       end;\n\njulia> speculate(Showcase; verbosity = debug)\n[ Info: Compiled `Main.Showcase.g(::Int)`\n[ Info: Compiled `Main.Showcase.f()`\n\njulia> speculate(Base.isexported, Showcase; verbosity = debug)\n[ Info: Skipped `Main.Showcase.g(::Int)`\n\njulia> speculate(Showcase.h; limit = 2, verbosity = debug)\n[ Info: Compiled `Main.Showcase.h(::String)`\n[ Info: Compiled `Main.Showcase.h(::Symbol)`\n\njulia> speculate_repl(; limit = 4, verbosity = debug)\n[ Info: The REPL will call `speculate` with each input\n\njulia> i(::Union{String, Symbol}, ::Union{String, Symbol}) = nothing;\n[ Info: Compiled `Main.i(::Symbol, ::Symbol)`\n[ Info: Compiled `Main.i(::String, ::Symbol)`\n[ Info: Compiled `Main.i(::Symbol, ::String)`\n[ Info: Compiled `Main.i(::String, ::String)`","category":"page"},{"location":"#Case-Study","page":"Speculator.jl","title":"Case Study","text":"","category":"section"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"Consider Plots.jl, the go-to example when discussing latency in Julia and the substantial improvements made to the time-to-first-X problem.","category":"page"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"julia> using Plots\n\njulia> @elapsed plot(1)\n0.106041791","category":"page"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"This call has very low latency, demonstrating that code for core functions has been effectively precompiled. However, it is challenging to manually identify an exhaustive set of methods to precompile. Speculator.jl can do this automatically.","category":"page"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"julia> @elapsed using Speculator\n0.040658097\n\njulia> SpeculationBenchmark(Plots)\nPrecompilation benchmark with `8` samples:\n  Mean:    `5.1130`\n  Median:  `5.1546`\n  Minimum: `4.7240`\n  Maximum: `5.5401`","category":"page"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"The SpeculationBenchmark estimates the compilation time that speculate saves. This case uses the minimum target, which only compiles methods of public functions, types, and the types of values, recursively for public modules. Although there are numerous additional targets, this target only precompiles a subset of the methods that are accessible to users as part of the Plots.jl public interface. This can be verified using speculate(Plots; verbosity = debug | review). Therefore, including this precompilation workload in Plots.jl or running it in the background of an interactive session can save up to five seconds of compilation time per session. Testing and selecting additional targets can save even more time.","category":"page"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"If instead, the Plots.jl workload did not precompile any new methods, using Speculator.jl would not meaningfully lengthen loading time. The package itself takes a fraction of a second to load in a package or interactive session. Running a workload in the background also only takes a fraction of a second to initiate. Therefore, using Speculator.jl has a high benefit to cost ratio in terms of compilation and loading time.","category":"page"},{"location":"#Features","page":"Speculator.jl","title":"Features","text":"","category":"section"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"Automatically generate a compilation workload from modules and callable objects.\nConfigurable to run in the background, select precompilation targets, and write to a file.\nCan be ran in the REPL after each input.\nBenchmark the compilation time of a workload.","category":"page"},{"location":"#Planned","page":"Speculator.jl","title":"Planned","text":"","category":"section"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"Disable during development using Preferences.jl?\nSupport for UnionAll types?","category":"page"},{"location":"#Acknowledgements","page":"Speculator.jl","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"Credit to Cameron Pfiffer for the initial idea.","category":"page"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"The preexisting package PrecompileSignatures.jl implements similar functionality, notably that PrecompileSignatures.@precompile_signatures ::Module is roughly equivalent to Speculator.speculate(::Module).","category":"page"},{"location":"#Similar-Packages","page":"Speculator.jl","title":"Similar Packages","text":"","category":"section"},{"location":"","page":"Speculator.jl","title":"Speculator.jl","text":"Cthulhu.jl\nJET.jl\nMethodAnalysis.jl\nPackageCacheInspector.jl\nPrecompileSignatures.jl\nPrecompileTools.jl\nSnoopCompile.jl\nSnoopCompileCore.jl","category":"page"}]
}
